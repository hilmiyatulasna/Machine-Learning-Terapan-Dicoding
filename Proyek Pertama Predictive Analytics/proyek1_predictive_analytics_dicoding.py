# -*- coding: utf-8 -*-
"""Proyek1_Predictive-Analytics_Dicoding.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s-ruqSw-MAIe5N6SJBLVm6IRLA1UKXjd

# 1. Install and Import Library
"""

!pip install wget
!pip install opendatasets

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy
import sklearn
import opendatasets
import wget
import zipfile
from tqdm import tqdm
import os

"""# 2. Load Dataset from Kaggle"""

if os.path.exists('diabetes-dataset/diabetes.csv'):
  print("file sudah ada")
else:
  opendatasets.download_kaggle_dataset(dataset_url='https://www.kaggle.com/datasets/akshaydattatraykhare/diabetes-dataset', data_dir='')

data = pd.read_csv("diabetes-dataset/diabetes.csv")
data

data.shape

"""# 3. Data Understanding

Informasi data:

Attribute  | Keterangan
------------- | -------------
Sumber | https://www.kaggle.com/datasets/akshaydattatraykhare/diabetes-dataset
Pregnancies | merepresentasikan Jumlah kehamilan
Glucose | merepresentasikan  tingkat Glukosa dalam darah
BloodPressure | merepresentasikan pengukuran tekanan darah
SkinThickness | merepresentasikan ketebalan kulit
Insulin | merepresentasikan tingkat Insulin dalam darah       
BMI | merepresentasikan indeks massa tubuh
DiabetesPedigreeFunction  | merepresentasikan persentase diabetes
Age |merepresentasikan umur
Outcome |merepresentasikan hasil akhir 1 adalah diabetes dan 0 adalah Tidak diabetes

## 3.1 Checking variable types in data
"""

data.info()

"""## 3.2 See the amount of data"""

print("Jumlah baris          :", data.shape[0])
print("Jumlah kolom          :", data.shape[1])

"""## 3.2 Check missing values"""

pd.DataFrame({
    'missing value':data.isnull().sum()
})

"""## 3.4 Check double duplicated data"""

data[data.duplicated()]

"""## 3.5 Statistical description of data"""

data.describe()

"""Fungsi describe() memberikan informasi statistik untuk setiap kolom, yang mencakup:
*   **Count**: jumlah sampel dalam data.
*   **Mean**: nilai rata-rata.
*   **Std**: standar deviasi.
*   **Min**: nilai terendah pada setiap kolom.
*   **25%**: kuartil pertama, yaitu nilai yang membagi data menjadi empat bagian yang masing-masing memiliki proporsi yang sama.
*   **50%**: kuartil kedua atau median, yang merupakan nilai tengah dari data.
*   **75%**: kuartil ketiga.
*   **Max**: nilai tertinggi pada kolom.

---
**Interpretasi Deskripsi Statistik Data**

Pada kolom Glucose, BloodPressure, SkinThickness, Insulin, dan BMI, terdapat nilai minimum sebesar 0. Nilai tersebut tidak wajar, karena kadar glukosa, tekanan darah, ketebalan kulit, kadar insulin, dan BMI pada manusia tidak mungkin mencapai nol. Oleh karena itu, nilai nol pada kolom-kolom tersebut akan dihapus.
"""

data = data.loc[(data[['Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI']]!=0).all(axis=1)]

data.describe()

data.shape

"""## 3.6 Data visualization

### 3.6.1 Column Pregnancies, and Outcome
"""

data_cols = ['Pregnancies', 'Outcome']
plt.figure(figsize = (15,8))
for i in range(len(data_cols)):
  plt.subplot(len(data_cols), 1, i + 1)  # i Rows , 1 cols
  sns.boxplot(x = data[data_cols[i]])
  plt.title('Boxplot of {}'.format(data_cols[i]))
  plt.tight_layout()

"""### 3.6.2 Column Glucose, BloodPressure, and SkinThickness"""

data_cols = ['Glucose',	'BloodPressure', 'SkinThickness']
plt.figure(figsize = (15,12))
for i in range(len(data_cols)):
  plt.subplot(3, 1, i + 1)  # 3 Rows , 1 cols
  sns.boxplot(x = data[data_cols[i]])
  plt.title('Boxplot of {}'.format(data_cols[i]))
  plt.tight_layout()

"""### 3.6.3 Column Insulin, BMI, DiabetesPedigreeFunction, Age"""

data_cols = ['Insulin',	'BMI', 'DiabetesPedigreeFunction',	'Age']
plt.figure(figsize = (15,12))

for i in range(len(data_cols)):
  plt.subplot(5, 1, i + 1)  # 3 Rows , 1 cols
  sns.boxplot(x = data[data_cols[i]])
  plt.title('Boxplot of {}'.format(data_cols[i]))
  plt.tight_layout()

"""### 3.6.4 Interpretasi Outlier of Boxplot.

*   Pada boxplot untuk kolom Pregnancies, terlihat adanya outlier pada jumlah kehamilan 13, 15, 16, dan 17. Data tersebut tidak dihapus karena seorang wanita mungkin saja melahirkan hingga 17 anak.
*   Pada boxplot kolom Insulin, kadar insulin menunjukkan fluktuasi yang signifikan, namun fluktuasi tersebut tidak dianggap sebagai outlier.
*   Pada boxplot DiabetesPedigreeFunction, nilai-nilai bervariasi berdasarkan riwayat keluarga, sehingga data tersebut tidak akan dihapus.
*   Pada boxplot kolom Age, meskipun ada nilai yang merupakan outlier, orang dengan usia seperti itu masih mungkin ada, sehingga data tersebut tidak dihapus.

## 3.6 Delete Outlier

Pada interpretasi outlier di boxplot, ditemukan bahwa data tidak dihapus, sehingga langkah ini dapat dilewati.

Q1 = data.quantile(0.25)
Q3 = data.quantile(0.75)
IQR=Q3-Q1
data=data[~((data<(Q1-1.5*IQR))|(data>(Q3+1.5*IQR))).any(axis=1)]
"""

data

"""# 4. Univariate Analysis

Pertama, dataset akan dibagi menjadi dua kategori fitur, yaitu Numerical Features dan Categorical Features.
"""

numerical_features = ['Glucose',	'BloodPressure',	'SkinThickness',	'Insulin',	'BMI',	'DiabetesPedigreeFunction',	'Age']
categorical_features = ['Pregnancies','Outcome']

"""##4.1 Categorical Features

###4.1.1 Pregnancies Features
"""

feature = categorical_features[0]
count = data[feature].value_counts()
percent = 100*data[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""Karena tidak ada korelasi yang ditemukan dalam data, maka kolom ini dihapus."""

data.drop('Pregnancies', axis=1, inplace=True)

"""###4.1.2 Outcome Features"""

feature = categorical_features[1]
count = data[feature].value_counts()
percent = 100*data[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""##4.2 Numerical Features"""

plt.figure(figsize = (20,18))

for i in range(len(numerical_features)):
    plt.subplot(len(numerical_features), 1, i + 1)  # 2 Rows , 2 cols
    sns.histplot(x = data[numerical_features[i]])
    plt.title('Displot of {}'.format(numerical_features[i]))
    plt.tight_layout()

"""Interpretasi histogram:
*   Beberapa kolom memiliki distribusi yang miring ke kanan.
*   Kolom dengan distribusi normal meliputi Glucose, BloodPressure, SkinThickness, dan BMI.
*   Kolom dengan distribusi miring ke kanan (right-skewed) adalah Insulin, DiabetesPedigreeFunction, dan Age.

#5. Multivariate Analysis
"""

data

data.shape

"""## 5.1 Seeing the relationship between Numerical Features and the objective function, namely Outcome"""

for i in range(len(numerical_features)):
    plt.figure(figsize = (25,50))
    plt.subplot(len(numerical_features), 1, i + 1)
    sns.kdeplot(x=data[numerical_features[i]], hue='Outcome',data=data)
    plt.title('Membandingkan distribusi {} penderita diabetes dan tanpa diabetes '.format(numerical_features[i]))
    plt.show()
    print('\n')

"""---------------------------
**Interpertasi**
Grafik perbandingan menunjukkan perbedaan antara individu yang terkena diabetes dan yang tidak, khususnya pada kolom Glucose, BloodPressure, BMI, DiabetesPedigreeFunction, dan Age.

--------
**Kesimpulan**
Dari data tersebut, dapat disimpulkan bahwa pasien yang menderita diabetes memiliki ciri-ciri sebagai berikut:
*   Pasien dengan glucose tinggi
*   Pasien dengan BloodPressure tinggi
*   Pasien dengan BMI tinggi
*   Pasien dengan nilai DiabetesPedigreeFunction tinggi
*   Pasien yang memiliki Age lebih tua

##5.2 Heat Map
"""

plt.figure(figsize=(10, 8))
correlation_matrix = data.corr().round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""-----
**Interpertasi**

Pada hasil heat map dapat dilihat bahwa diabetes berkorelasi dengan glucose, BMI dan age.

#6. Data Preparation

Balancing Dataset
"""

data_majority_0 = data[(data['Outcome']==0)]
data_minority_1 = data[(data['Outcome']==1)]


data_minority_upsampled = sklearn.utils.resample(data_minority_1,
                                 replace=True,
                                 n_samples= 260,
                                 random_state=42)

data = pd.concat([data_minority_upsampled, data_majority_0])

sns.countplot(x=data['Outcome'])

from sklearn.model_selection import train_test_split

X= data.drop(columns="Outcome")
y = data["Outcome"]

X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.8, shuffle=True, random_state=100)

"""# 7. Model Development

## 7.1 K-Nearest Neighbor
"""

from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier(n_neighbors=2)
knn.fit(X_train, y_train)

"""## 7.2 Random Forest"""

# Import library
from sklearn.ensemble import RandomForestClassifier

# make predictions model
RF = RandomForestClassifierModel = RandomForestClassifier(criterion = 'gini',n_estimators=100,max_depth=9,random_state=44)
RF.fit(X_train, y_train)

"""## 7.3 Boosting Algorithm"""

from sklearn.ensemble import AdaBoostClassifier

boosting = AdaBoostClassifier()
boosting.fit(X_train, y_train)

"""# 8. Evaluasi Model"""

# Prepare dataframe for model analysis
models = [knn, RF, boosting]
models_names= ["KNearestNeighbor","Random Forest","Boosting"]
mean_score = []

for model in models:
    cross_score = sklearn.model_selection.cross_val_score(model,X_train,y_train,cv=5)
    average_score = np.mean(cross_score)
    mean_score.append(average_score)

# Diagram Performances Models
plt.figure(figsize=(8,6))
sns.barplot(x=models_names, y=mean_score)
plt.title("Performance Models")
plt.show()

"""Pada diagram Performance Models, Random Forest menunjukkan kinerja yang sangat baik. Oleh karena itu, kita akan memilih Random Forest untuk digunakan."""

print('Train RandomForestClassifierModel  : ' , RF.score(X_train, y_train))
print('Test RandomForestClassifierModel : ' , RF.score(X_test, y_test))

y_pred_RF = RandomForestClassifierModel.predict(X_test)
RF = sklearn.metrics.confusion_matrix(y_test,y_pred_RF)

ax=sns.heatmap(RF,annot=True,fmt=".2f")
ax.set_xticklabels(["Negatif", "Positif"])
ax.set_yticklabels(["Negatif", "Positif"])
plt.title("Confusion Matrix untuk Random Forest ")
plt.show()

RF_test_score = sklearn.metrics.accuracy_score(y_test,y_pred_RF)
print("Akurasi Random Forest Classifier : {}".format(RF_test_score))

print("-" * 100)

RF_precision_score = sklearn.metrics.precision_score(y_test,y_pred_RF)
print("Precision Random Forest Classifier : {}".format(RF_precision_score))

print("-" * 100)

RF_recall_score = sklearn.metrics.recall_score(y_test,y_pred_RF)
print("Recall Random Forest Classifier : {}".format(RF_recall_score))

print("-" * 100)

f1_score = sklearn.metrics.f1_score(y_test,y_pred_RF)
print("F1 score Random Forest Classifier : {}".format(f1_score))